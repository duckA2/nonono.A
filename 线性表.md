


# 定义与特点
  具有相同特性的**数据元素**(结点)的一个**有限序列**，数据元素间关系是**线性**
 * 由数据元素个数定义为表的长度
 * n=0,即为空表
 * 直接前驱 直接后继
 * 线性起点 线性终点
 * 从具体应用中抽象出共性的逻辑结构和基本操作，然后实现其存储结构和基本操作
  # 类型定义
  ##  基本操作
 * 构造一个空的线性表
* 销毁线性表
* 将线性表重置为空表
* 判断一个线性表是否为空
* 求一个线性表的长度
* 返回线性表中第i个元素值
* 返回第一个满足条件的数据元素的位序
* 求元素的前驱，后继
* 线性表中插入一个元素
* 删除一个线性表中元素
* 依次对元素进行操作
# 顺序存储结构表示与实现
## 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中
* 基地址
* 地址连续
* 随机存取
* 类型相同
## 实现（数组）
线性表长度可变
数组长度不可动态定义
额外用一个变量表示线性表长度

```
#define MAXSIZE 1000//多项式可能达到的最大长度

typedef struct  {//多项式非0项的定义
	float p;//系数
	int e;//指数
}Polynomial;

typedef struct {
	Polynomial *elem;//存储空间的基地址
	int length;//当前项的个数
}SqList;

```
 * 直接映射 逻辑位序与物理位序相差1
`类c
```
#define MAXSIZE 100;
typedef struct {
	ElemType *elem;
	int length;
}SqList;
SqList L;
L.elem[0]
```
 * 线性表的初始化
```
Status InitList_Sq(SqList &L){
	L.elem=new ElemType[MAXSIZE];
	if(!L.elem) exit(OVERFLOW);
	L.length=0;
	return OK；
}
```
```
void DestroyList(SqList &L){
	if(L.elem) delete L.elem;
}
```
```
void ClearList(SqList &L) {
	L.length=0;
}
```
```
int GetElem(SqList L,int i,ElemType &e){
if(i<1||i>L.length)	return ERROR;
	e=L.elem[i-1}
	return OK;
}
``` 
# 链式表示与实现
 * 单链表是由头指针唯一确定，因此单链表可以用头指针的名字来命名
 * 结点：数据元素的存储映像，由数据域和指针域两部分组成
 * 双链表：结点由两个指针域的链表
 * 循环链表：首尾相接的链表
 * 头指针：指向链表第一个结点的指针
 * 首元结点：链表中存储第一个数据元素的结点
 * 头结点:在链表首元结点之前附设的一个结点
## 如何表示空表
无头结点时，头指针为空几位空表
有头结点时，头结点指针域为空
## 特点
 * 结点在存储器中存储位置任意，即逻辑上相邻的数据元素在物理上不一定相邻
 * 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余节点
**顺序表——随机存取；链表——顺序存取**
 

	

																																																																																																								





	
